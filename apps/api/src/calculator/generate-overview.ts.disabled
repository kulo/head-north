/**
 * Generate Overview Module
 * 
 * This module generates a structured overview of roadmap items with their associated
 * sprints, release items, and GTM (Go-To-Market) plan validations.
 * 
 * The main purpose is to transform raw Jira data into a hierarchical structure
 * suitable for GTM planning and validation, focusing on:
 * - Roadmap item organization by initiatives
 * - Sprint-based release item grouping
 * - GTM plan validation (scheduled releases, backlog items)
 * - External release item filtering
 * 
 * @fileoverview Overview generation for GTM planning and validation
 * 
 * @deprecated This module is currently commented out and not used in production.
 * See CLEANUP_TODOS.md for integration options and future plans.
 */

/*
import { ReleaseItemParser } from "./release-item-parser";
import { RoadmapItemParser } from "./roadmap-item-parser";
import {
  resolveStage,
  isReleasableStage,
  isFinalReleaseStage,
} from "./resolve-stage";
import { resolveStatus } from "./resolve-status";
import type { OmegaConfig } from "@omega/config";

/**
 * Utility function to check if a sprint/roadmap item has any release items
 * @param x - Object with releaseItems array
 * @returns True if releaseItems array has length > 0
 */
const hasAnyReleaseItem = (x: { releaseItems: unknown[] }) =>
  x.releaseItems.length > 0;

/**
 * Determines if a release item is scheduled for a future sprint
 * 
 * This function handles both raw Jira issues (with fields.sprint) and parsed release items
 * (with sprint property). It prioritizes raw Jira data over parsed data for accuracy.
 * 
 * @param issueFields - Object containing sprint information
 * @param issueFields.sprint - Parsed sprint data (optional)
 * @param issueFields.fields - Raw Jira fields (optional)
 * @param issueFields.fields.sprint - Raw Jira sprint data (optional)
 * @returns True if the item is scheduled for a sprint that ends in the future
 * 
 * @example
 * // Raw Jira issue
 * isScheduledForFuture({
 *   fields: { sprint: { endDate: "2024-12-31T23:59:59.000Z" } }
 * }); // Returns true if current date < 2024-12-31
 * 
 * // Parsed release item
 * isScheduledForFuture({
 *   sprint: { endDate: "2024-12-31T23:59:59.000Z" }
 * }); // Returns true if current date < 2024-12-31
 */
const isScheduledForFuture = (issueFields: {
  sprint?: { endDate: string };
  fields?: { sprint?: { endDate: string } };
}): boolean => {
  // Handle both raw Jira issues (fields.sprint) and parsed release items (sprint)
  // Prioritize fields.sprint (raw Jira data) over sprint (parsed data)
  const sprint = issueFields.fields?.sprint || issueFields.sprint;
  return (
    !!sprint && new Date() < new Date(sprint.endDate)
  );
};

/**
 * Determines if a release item is in the backlog (not assigned to any sprint)
 * 
 * An item is considered "in backlog" if:
 * 1. It has a future status (e.g., "To Do", "Open")
 * 2. It is not assigned to any sprint (sprint is null/undefined)
 * 
 * This function handles both raw Jira issues and parsed release items, prioritizing
 * raw Jira data for accuracy.
 * 
 * @param issueFields - Object containing sprint and status information
 * @param issueFields.sprint - Parsed sprint data (optional)
 * @param issueFields.fields - Raw Jira fields (optional)
 * @param issueFields.fields.sprint - Raw Jira sprint data (optional)
 * @param omegaConfig - Configuration object with status validation methods
 * @returns True if the item is in backlog (future status + no sprint assignment)
 * 
 * @example
 * // Item in backlog
 * isInBacklog({
 *   fields: { sprint: null, status: { name: "To Do" } }
 * }, omegaConfig); // Returns true
 * 
 * // Item assigned to sprint
 * isInBacklog({
 *   fields: { sprint: { id: "123" }, status: { name: "To Do" } }
 * }, omegaConfig); // Returns false
 */
const isInBacklog = (
  issueFields: { sprint?: unknown; fields?: { sprint?: unknown } },
  omegaConfig: OmegaConfig,
): boolean => {
  const status = resolveStatus(issueFields, null, omegaConfig);
  // Handle both raw Jira issues (fields.sprint) and parsed release items (sprint)
  // Prioritize fields.sprint (raw Jira data) over sprint (parsed data)
  // If fields.sprint exists (even if null), use it; otherwise use sprint
  const sprint = issueFields.fields !== undefined ? issueFields.fields.sprint : issueFields.sprint;
  return omegaConfig.isFutureStatus(status) && !sprint;
};

/**
 * Validates a Go-To-Market (GTM) plan by analyzing release items
 * 
 * This function performs GTM plan validation by checking two key criteria:
 * 1. **hasScheduledRelease**: Whether there's a release item scheduled for a future sprint
 *    that is in a releasable stage (e.g., s2, s3, s3+)
 * 2. **hasGlobalReleaseInBacklog**: Whether there's a release item in backlog or future sprint
 *    that is in a final release stage (e.g., s3+)
 * 
 * The validation helps ensure that GTM plans have proper release scheduling and
 * include global releases for market readiness.
 * 
 * @param releaseItems - Array of release items to validate (can be raw Jira issues or parsed items)
 * @param omegaConfig - Configuration object with stage and status validation methods
 * @returns Object containing GTM validation results
 * @returns returns.hasScheduledRelease - True if there's a scheduled release in releasable stage
 * @returns returns.hasGlobalReleaseInBacklog - True if there's a global release in backlog/future sprint
 * 
 * @example
 * const validation = validateGTMPlan([
 *   { summary: "Feature A (s2)", fields: { sprint: { endDate: "2024-12-31" } } },
 *   { summary: "Global Release (s3+)", fields: { sprint: null } }
 * ], omegaConfig);
 * // Returns: { hasScheduledRelease: true, hasGlobalReleaseInBacklog: true }
 */
const validateGTMPlan = (releaseItems: unknown[], omegaConfig: OmegaConfig) => {
  if (!releaseItems) return {};
  
  const releaseItemStates = releaseItems.map((releaseItem) => {
    // Handle both raw Jira issues (with fields.summary) and parsed release items (with summary)
    const summary = releaseItem.summary || releaseItem.fields?.summary;
    const stage = resolveStage(summary, omegaConfig);
    return {
      stage,
      isInFutureSprint: isScheduledForFuture(releaseItem),
      isInBacklog: isInBacklog(releaseItem, omegaConfig),
      isReleasableStage: isReleasableStage(stage, omegaConfig),
      isFinalReleaseStage: isFinalReleaseStage(stage, omegaConfig),
      isPossibleFutureStatus: omegaConfig.isFutureStatus(
        resolveStatus(releaseItem, null, omegaConfig),
      ),
    };
  });
  return {
    hasScheduledRelease: releaseItemStates.some((releaseItemState) => {
      return (
        releaseItemState.isInFutureSprint && releaseItemState.isReleasableStage
      );
    }),
    hasGlobalReleaseInBacklog: releaseItemStates.some((releaseItemState) => {
      return (
        (releaseItemState.isInBacklog || releaseItemState.isInFutureSprint) &&
        releaseItemState.isFinalReleaseStage
      );
    }),
  };
};

/**
 * Generates a structured overview of roadmap items with sprints and GTM validation
 * 
 * This is the main function that transforms raw Jira data into a hierarchical structure
 * suitable for GTM planning and validation. It processes issues, groups them by sprints
 * and roadmap items, and performs GTM plan validation.
 * 
 * **Data Flow:**
 * 1. Parse issues into release items using ReleaseItemParser
 * 2. Group release items by sprints
 * 3. Parse roadmap items using RoadmapItemParser
 * 4. Filter to only external release items
 * 5. Perform GTM plan validation for each roadmap item
 * 6. Return structured overview data
 * 
 * **Key Features:**
 * - Sprint-based release item grouping
 * - Initiative-based roadmap item organization
 * - GTM plan validation (scheduled releases, backlog items)
 * - External release item filtering
 * - Comprehensive validation and error handling
 * 
 * @param issues - 2D array of issues grouped by sprints (issues[sprintIndex][issueIndex])
 * @param issuesByRoadmapItems - Object mapping roadmap item IDs to their associated issues
 * @param roadmapItems - Object mapping roadmap item IDs to roadmap item data
 * @param sprints - Array of sprint objects with id, name, dates, etc.
 * @param omegaConfig - Configuration object with parsing and validation methods
 * @returns Array of roadmap item overview objects with sprints and validations
 * 
 * @returns Each roadmap item object contains:
 * @returns returns[].summary - Roadmap item name/summary
 * @returns returns[].id - Initiative ID
 * @returns returns[].name - Initiative name
 * @returns returns[].theme - Theme information
 * @returns returns[].area - Area information
 * @returns returns[].url - Roadmap item URL
 * @returns returns[].validations - GTM plan validation results
 * @returns returns[].sprints - Array of sprints with release items
 * 
 * @example
 * const overview = generateOverview(
 *   [[issue1, issue2], [issue3]], // Issues by sprint
 *   { "ROADMAP-1": [issue1, issue2] }, // Issues by roadmap item
 *   { "ROADMAP-1": roadmapData }, // Roadmap item data
 *   [sprint1, sprint2], // Sprint data
 *   omegaConfig
 * );
 * // Returns: [{ summary: "Feature A", id: "init-1", sprints: [...], validations: {...} }]
 */
export default (
  issues: unknown[][],
  issuesByRoadmapItems: Record<string, unknown[]>,
  roadmapItems: Record<string, unknown>,
  sprints: unknown[],
  omegaConfig: OmegaConfig,
): unknown[] => {
  const roadmapItemParser = new RoadmapItemParser(roadmapItems, omegaConfig);
  
  // Step 1: Parse issues into release items grouped by sprints
  const releaseItemsPerSprintGroups = issues.map((issueList, index) => {
    const currentSprint = sprints[index];
    const parser = new ReleaseItemParser(currentSprint, omegaConfig);
    const releaseItems = issueList.map((issue: unknown) => parser.parse(issue));

    return {
      sprintId: currentSprint.id,
      releaseItems: releaseItems,
    };
  });

  // Step 2: Process each roadmap item and generate overview structure
  const roadmapItemsResult = Object.entries(roadmapItems)
    .map(([id, _roadmapItemData]) => {
      // Parse the roadmap item to get initiative, theme, area info
      const roadmapItem = roadmapItemParser.parse(
        id,
        issuesByRoadmapItems[id] || [],
      );
      
      // Step 3: Build the roadmap item overview structure
      return {
        summary: roadmapItem.name,
        id: roadmapItem.initiative?.id || "unknown",
        name: roadmapItem.initiative?.name || "Unknown",
        theme: roadmapItem.theme,
        area: roadmapItem.area,
        url: roadmapItem.url,
        // Step 4: Perform GTM plan validation using raw issues
        validations: validateGTMPlan(issuesByRoadmapItems[id] || [], omegaConfig),
        // Step 5: Build sprints array with filtered external release items
        sprints: releaseItemsPerSprintGroups
          .map((releaseItems) => {
            // Filter release items that belong to this roadmap item
            const releaseItemsForRoadmapItem = releaseItems.releaseItems.filter(
              (item: { projectId: string }) => item.projectId === id,
            );
            // Re-parse to ensure proper structure
            const { releaseItems: parsedReleaseItems } =
              roadmapItemParser.parse(id, releaseItemsForRoadmapItem);
            return {
              ...releaseItems,
              // Only include external release items (filter out internal ones)
              releaseItems: parsedReleaseItems.filter(
                (item: { isExternal: boolean }) => item.isExternal,
              ),
            };
          })
          .filter(hasAnyReleaseItem), // Remove sprints with no release items
      };
    })
    .filter((entry) => entry.sprints.some(hasAnyReleaseItem)); // Remove roadmap items with no sprints

  return roadmapItemsResult;
};
*/
